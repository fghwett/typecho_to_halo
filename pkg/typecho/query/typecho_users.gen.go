// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/fghwett/typecho-to-halo/pkg/typecho/model"
)

func newTypechoUsers(db *gorm.DB, opts ...gen.DOOption) typechoUsers {
	_typechoUsers := typechoUsers{}

	_typechoUsers.typechoUsersDo.UseDB(db, opts...)
	_typechoUsers.typechoUsersDo.UseModel(&model.TypechoUsers{})

	tableName := _typechoUsers.typechoUsersDo.TableName()
	_typechoUsers.ALL = field.NewAsterisk(tableName)
	_typechoUsers.UID = field.NewUint32(tableName, "uid")
	_typechoUsers.Name = field.NewString(tableName, "name")
	_typechoUsers.Password = field.NewString(tableName, "password")
	_typechoUsers.Mail = field.NewString(tableName, "mail")
	_typechoUsers.URL = field.NewString(tableName, "url")
	_typechoUsers.ScreenName = field.NewString(tableName, "screenName")
	_typechoUsers.Created = field.NewUint32(tableName, "created")
	_typechoUsers.Activated = field.NewUint32(tableName, "activated")
	_typechoUsers.Logged = field.NewUint32(tableName, "logged")
	_typechoUsers.Group_ = field.NewString(tableName, "group")
	_typechoUsers.AuthCode = field.NewString(tableName, "authCode")

	_typechoUsers.fillFieldMap()

	return _typechoUsers
}

type typechoUsers struct {
	typechoUsersDo

	ALL        field.Asterisk
	UID        field.Uint32
	Name       field.String
	Password   field.String
	Mail       field.String
	URL        field.String
	ScreenName field.String
	Created    field.Uint32
	Activated  field.Uint32
	Logged     field.Uint32
	Group_     field.String
	AuthCode   field.String

	fieldMap map[string]field.Expr
}

func (t typechoUsers) Table(newTableName string) *typechoUsers {
	t.typechoUsersDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t typechoUsers) As(alias string) *typechoUsers {
	t.typechoUsersDo.DO = *(t.typechoUsersDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *typechoUsers) updateTableName(table string) *typechoUsers {
	t.ALL = field.NewAsterisk(table)
	t.UID = field.NewUint32(table, "uid")
	t.Name = field.NewString(table, "name")
	t.Password = field.NewString(table, "password")
	t.Mail = field.NewString(table, "mail")
	t.URL = field.NewString(table, "url")
	t.ScreenName = field.NewString(table, "screenName")
	t.Created = field.NewUint32(table, "created")
	t.Activated = field.NewUint32(table, "activated")
	t.Logged = field.NewUint32(table, "logged")
	t.Group_ = field.NewString(table, "group")
	t.AuthCode = field.NewString(table, "authCode")

	t.fillFieldMap()

	return t
}

func (t *typechoUsers) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *typechoUsers) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 11)
	t.fieldMap["uid"] = t.UID
	t.fieldMap["name"] = t.Name
	t.fieldMap["password"] = t.Password
	t.fieldMap["mail"] = t.Mail
	t.fieldMap["url"] = t.URL
	t.fieldMap["screenName"] = t.ScreenName
	t.fieldMap["created"] = t.Created
	t.fieldMap["activated"] = t.Activated
	t.fieldMap["logged"] = t.Logged
	t.fieldMap["group"] = t.Group_
	t.fieldMap["authCode"] = t.AuthCode
}

func (t typechoUsers) clone(db *gorm.DB) typechoUsers {
	t.typechoUsersDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t typechoUsers) replaceDB(db *gorm.DB) typechoUsers {
	t.typechoUsersDo.ReplaceDB(db)
	return t
}

type typechoUsersDo struct{ gen.DO }

type ITypechoUsersDo interface {
	gen.SubQuery
	Debug() ITypechoUsersDo
	WithContext(ctx context.Context) ITypechoUsersDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITypechoUsersDo
	WriteDB() ITypechoUsersDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITypechoUsersDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITypechoUsersDo
	Not(conds ...gen.Condition) ITypechoUsersDo
	Or(conds ...gen.Condition) ITypechoUsersDo
	Select(conds ...field.Expr) ITypechoUsersDo
	Where(conds ...gen.Condition) ITypechoUsersDo
	Order(conds ...field.Expr) ITypechoUsersDo
	Distinct(cols ...field.Expr) ITypechoUsersDo
	Omit(cols ...field.Expr) ITypechoUsersDo
	Join(table schema.Tabler, on ...field.Expr) ITypechoUsersDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITypechoUsersDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITypechoUsersDo
	Group(cols ...field.Expr) ITypechoUsersDo
	Having(conds ...gen.Condition) ITypechoUsersDo
	Limit(limit int) ITypechoUsersDo
	Offset(offset int) ITypechoUsersDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITypechoUsersDo
	Unscoped() ITypechoUsersDo
	Create(values ...*model.TypechoUsers) error
	CreateInBatches(values []*model.TypechoUsers, batchSize int) error
	Save(values ...*model.TypechoUsers) error
	First() (*model.TypechoUsers, error)
	Take() (*model.TypechoUsers, error)
	Last() (*model.TypechoUsers, error)
	Find() ([]*model.TypechoUsers, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TypechoUsers, err error)
	FindInBatches(result *[]*model.TypechoUsers, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.TypechoUsers) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITypechoUsersDo
	Assign(attrs ...field.AssignExpr) ITypechoUsersDo
	Joins(fields ...field.RelationField) ITypechoUsersDo
	Preload(fields ...field.RelationField) ITypechoUsersDo
	FirstOrInit() (*model.TypechoUsers, error)
	FirstOrCreate() (*model.TypechoUsers, error)
	FindByPage(offset int, limit int) (result []*model.TypechoUsers, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITypechoUsersDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t typechoUsersDo) Debug() ITypechoUsersDo {
	return t.withDO(t.DO.Debug())
}

func (t typechoUsersDo) WithContext(ctx context.Context) ITypechoUsersDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t typechoUsersDo) ReadDB() ITypechoUsersDo {
	return t.Clauses(dbresolver.Read)
}

func (t typechoUsersDo) WriteDB() ITypechoUsersDo {
	return t.Clauses(dbresolver.Write)
}

func (t typechoUsersDo) Session(config *gorm.Session) ITypechoUsersDo {
	return t.withDO(t.DO.Session(config))
}

func (t typechoUsersDo) Clauses(conds ...clause.Expression) ITypechoUsersDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t typechoUsersDo) Returning(value interface{}, columns ...string) ITypechoUsersDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t typechoUsersDo) Not(conds ...gen.Condition) ITypechoUsersDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t typechoUsersDo) Or(conds ...gen.Condition) ITypechoUsersDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t typechoUsersDo) Select(conds ...field.Expr) ITypechoUsersDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t typechoUsersDo) Where(conds ...gen.Condition) ITypechoUsersDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t typechoUsersDo) Order(conds ...field.Expr) ITypechoUsersDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t typechoUsersDo) Distinct(cols ...field.Expr) ITypechoUsersDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t typechoUsersDo) Omit(cols ...field.Expr) ITypechoUsersDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t typechoUsersDo) Join(table schema.Tabler, on ...field.Expr) ITypechoUsersDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t typechoUsersDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITypechoUsersDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t typechoUsersDo) RightJoin(table schema.Tabler, on ...field.Expr) ITypechoUsersDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t typechoUsersDo) Group(cols ...field.Expr) ITypechoUsersDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t typechoUsersDo) Having(conds ...gen.Condition) ITypechoUsersDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t typechoUsersDo) Limit(limit int) ITypechoUsersDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t typechoUsersDo) Offset(offset int) ITypechoUsersDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t typechoUsersDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITypechoUsersDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t typechoUsersDo) Unscoped() ITypechoUsersDo {
	return t.withDO(t.DO.Unscoped())
}

func (t typechoUsersDo) Create(values ...*model.TypechoUsers) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t typechoUsersDo) CreateInBatches(values []*model.TypechoUsers, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t typechoUsersDo) Save(values ...*model.TypechoUsers) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t typechoUsersDo) First() (*model.TypechoUsers, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TypechoUsers), nil
	}
}

func (t typechoUsersDo) Take() (*model.TypechoUsers, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TypechoUsers), nil
	}
}

func (t typechoUsersDo) Last() (*model.TypechoUsers, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TypechoUsers), nil
	}
}

func (t typechoUsersDo) Find() ([]*model.TypechoUsers, error) {
	result, err := t.DO.Find()
	return result.([]*model.TypechoUsers), err
}

func (t typechoUsersDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TypechoUsers, err error) {
	buf := make([]*model.TypechoUsers, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t typechoUsersDo) FindInBatches(result *[]*model.TypechoUsers, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t typechoUsersDo) Attrs(attrs ...field.AssignExpr) ITypechoUsersDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t typechoUsersDo) Assign(attrs ...field.AssignExpr) ITypechoUsersDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t typechoUsersDo) Joins(fields ...field.RelationField) ITypechoUsersDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t typechoUsersDo) Preload(fields ...field.RelationField) ITypechoUsersDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t typechoUsersDo) FirstOrInit() (*model.TypechoUsers, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TypechoUsers), nil
	}
}

func (t typechoUsersDo) FirstOrCreate() (*model.TypechoUsers, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TypechoUsers), nil
	}
}

func (t typechoUsersDo) FindByPage(offset int, limit int) (result []*model.TypechoUsers, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t typechoUsersDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t typechoUsersDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t typechoUsersDo) Delete(models ...*model.TypechoUsers) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *typechoUsersDo) withDO(do gen.Dao) *typechoUsersDo {
	t.DO = *do.(*gen.DO)
	return t
}
