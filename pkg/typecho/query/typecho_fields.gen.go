// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/fghwett/typecho-to-halo/pkg/typecho/model"
)

func newTypechoFields(db *gorm.DB, opts ...gen.DOOption) typechoFields {
	_typechoFields := typechoFields{}

	_typechoFields.typechoFieldsDo.UseDB(db, opts...)
	_typechoFields.typechoFieldsDo.UseModel(&model.TypechoFields{})

	tableName := _typechoFields.typechoFieldsDo.TableName()
	_typechoFields.ALL = field.NewAsterisk(tableName)
	_typechoFields.Cid = field.NewUint32(tableName, "cid")
	_typechoFields.Name = field.NewString(tableName, "name")
	_typechoFields.Type = field.NewString(tableName, "type")
	_typechoFields.StrValue = field.NewString(tableName, "str_value")
	_typechoFields.IntValue = field.NewInt32(tableName, "int_value")
	_typechoFields.FloatValue = field.NewFloat32(tableName, "float_value")

	_typechoFields.fillFieldMap()

	return _typechoFields
}

type typechoFields struct {
	typechoFieldsDo

	ALL        field.Asterisk
	Cid        field.Uint32
	Name       field.String
	Type       field.String
	StrValue   field.String
	IntValue   field.Int32
	FloatValue field.Float32

	fieldMap map[string]field.Expr
}

func (t typechoFields) Table(newTableName string) *typechoFields {
	t.typechoFieldsDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t typechoFields) As(alias string) *typechoFields {
	t.typechoFieldsDo.DO = *(t.typechoFieldsDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *typechoFields) updateTableName(table string) *typechoFields {
	t.ALL = field.NewAsterisk(table)
	t.Cid = field.NewUint32(table, "cid")
	t.Name = field.NewString(table, "name")
	t.Type = field.NewString(table, "type")
	t.StrValue = field.NewString(table, "str_value")
	t.IntValue = field.NewInt32(table, "int_value")
	t.FloatValue = field.NewFloat32(table, "float_value")

	t.fillFieldMap()

	return t
}

func (t *typechoFields) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *typechoFields) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 6)
	t.fieldMap["cid"] = t.Cid
	t.fieldMap["name"] = t.Name
	t.fieldMap["type"] = t.Type
	t.fieldMap["str_value"] = t.StrValue
	t.fieldMap["int_value"] = t.IntValue
	t.fieldMap["float_value"] = t.FloatValue
}

func (t typechoFields) clone(db *gorm.DB) typechoFields {
	t.typechoFieldsDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t typechoFields) replaceDB(db *gorm.DB) typechoFields {
	t.typechoFieldsDo.ReplaceDB(db)
	return t
}

type typechoFieldsDo struct{ gen.DO }

type ITypechoFieldsDo interface {
	gen.SubQuery
	Debug() ITypechoFieldsDo
	WithContext(ctx context.Context) ITypechoFieldsDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITypechoFieldsDo
	WriteDB() ITypechoFieldsDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITypechoFieldsDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITypechoFieldsDo
	Not(conds ...gen.Condition) ITypechoFieldsDo
	Or(conds ...gen.Condition) ITypechoFieldsDo
	Select(conds ...field.Expr) ITypechoFieldsDo
	Where(conds ...gen.Condition) ITypechoFieldsDo
	Order(conds ...field.Expr) ITypechoFieldsDo
	Distinct(cols ...field.Expr) ITypechoFieldsDo
	Omit(cols ...field.Expr) ITypechoFieldsDo
	Join(table schema.Tabler, on ...field.Expr) ITypechoFieldsDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITypechoFieldsDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITypechoFieldsDo
	Group(cols ...field.Expr) ITypechoFieldsDo
	Having(conds ...gen.Condition) ITypechoFieldsDo
	Limit(limit int) ITypechoFieldsDo
	Offset(offset int) ITypechoFieldsDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITypechoFieldsDo
	Unscoped() ITypechoFieldsDo
	Create(values ...*model.TypechoFields) error
	CreateInBatches(values []*model.TypechoFields, batchSize int) error
	Save(values ...*model.TypechoFields) error
	First() (*model.TypechoFields, error)
	Take() (*model.TypechoFields, error)
	Last() (*model.TypechoFields, error)
	Find() ([]*model.TypechoFields, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TypechoFields, err error)
	FindInBatches(result *[]*model.TypechoFields, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.TypechoFields) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITypechoFieldsDo
	Assign(attrs ...field.AssignExpr) ITypechoFieldsDo
	Joins(fields ...field.RelationField) ITypechoFieldsDo
	Preload(fields ...field.RelationField) ITypechoFieldsDo
	FirstOrInit() (*model.TypechoFields, error)
	FirstOrCreate() (*model.TypechoFields, error)
	FindByPage(offset int, limit int) (result []*model.TypechoFields, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITypechoFieldsDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t typechoFieldsDo) Debug() ITypechoFieldsDo {
	return t.withDO(t.DO.Debug())
}

func (t typechoFieldsDo) WithContext(ctx context.Context) ITypechoFieldsDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t typechoFieldsDo) ReadDB() ITypechoFieldsDo {
	return t.Clauses(dbresolver.Read)
}

func (t typechoFieldsDo) WriteDB() ITypechoFieldsDo {
	return t.Clauses(dbresolver.Write)
}

func (t typechoFieldsDo) Session(config *gorm.Session) ITypechoFieldsDo {
	return t.withDO(t.DO.Session(config))
}

func (t typechoFieldsDo) Clauses(conds ...clause.Expression) ITypechoFieldsDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t typechoFieldsDo) Returning(value interface{}, columns ...string) ITypechoFieldsDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t typechoFieldsDo) Not(conds ...gen.Condition) ITypechoFieldsDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t typechoFieldsDo) Or(conds ...gen.Condition) ITypechoFieldsDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t typechoFieldsDo) Select(conds ...field.Expr) ITypechoFieldsDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t typechoFieldsDo) Where(conds ...gen.Condition) ITypechoFieldsDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t typechoFieldsDo) Order(conds ...field.Expr) ITypechoFieldsDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t typechoFieldsDo) Distinct(cols ...field.Expr) ITypechoFieldsDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t typechoFieldsDo) Omit(cols ...field.Expr) ITypechoFieldsDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t typechoFieldsDo) Join(table schema.Tabler, on ...field.Expr) ITypechoFieldsDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t typechoFieldsDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITypechoFieldsDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t typechoFieldsDo) RightJoin(table schema.Tabler, on ...field.Expr) ITypechoFieldsDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t typechoFieldsDo) Group(cols ...field.Expr) ITypechoFieldsDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t typechoFieldsDo) Having(conds ...gen.Condition) ITypechoFieldsDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t typechoFieldsDo) Limit(limit int) ITypechoFieldsDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t typechoFieldsDo) Offset(offset int) ITypechoFieldsDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t typechoFieldsDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITypechoFieldsDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t typechoFieldsDo) Unscoped() ITypechoFieldsDo {
	return t.withDO(t.DO.Unscoped())
}

func (t typechoFieldsDo) Create(values ...*model.TypechoFields) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t typechoFieldsDo) CreateInBatches(values []*model.TypechoFields, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t typechoFieldsDo) Save(values ...*model.TypechoFields) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t typechoFieldsDo) First() (*model.TypechoFields, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TypechoFields), nil
	}
}

func (t typechoFieldsDo) Take() (*model.TypechoFields, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TypechoFields), nil
	}
}

func (t typechoFieldsDo) Last() (*model.TypechoFields, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TypechoFields), nil
	}
}

func (t typechoFieldsDo) Find() ([]*model.TypechoFields, error) {
	result, err := t.DO.Find()
	return result.([]*model.TypechoFields), err
}

func (t typechoFieldsDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TypechoFields, err error) {
	buf := make([]*model.TypechoFields, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t typechoFieldsDo) FindInBatches(result *[]*model.TypechoFields, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t typechoFieldsDo) Attrs(attrs ...field.AssignExpr) ITypechoFieldsDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t typechoFieldsDo) Assign(attrs ...field.AssignExpr) ITypechoFieldsDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t typechoFieldsDo) Joins(fields ...field.RelationField) ITypechoFieldsDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t typechoFieldsDo) Preload(fields ...field.RelationField) ITypechoFieldsDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t typechoFieldsDo) FirstOrInit() (*model.TypechoFields, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TypechoFields), nil
	}
}

func (t typechoFieldsDo) FirstOrCreate() (*model.TypechoFields, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TypechoFields), nil
	}
}

func (t typechoFieldsDo) FindByPage(offset int, limit int) (result []*model.TypechoFields, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t typechoFieldsDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t typechoFieldsDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t typechoFieldsDo) Delete(models ...*model.TypechoFields) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *typechoFieldsDo) withDO(do gen.Dao) *typechoFieldsDo {
	t.DO = *do.(*gen.DO)
	return t
}
