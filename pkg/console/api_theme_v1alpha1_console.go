/*
Halo

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.20.18
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package console_sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"os"
)


type ThemeV1alpha1ConsoleAPI interface {

	/*
	ActivateTheme Method for ActivateTheme

	Activate a theme by name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiActivateThemeRequest
	*/
	ActivateTheme(ctx context.Context, name string) ApiActivateThemeRequest

	// ActivateThemeExecute executes the request
	//  @return Theme
	ActivateThemeExecute(r ApiActivateThemeRequest) (*Theme, *http.Response, error)

	/*
	FetchActivatedTheme Method for FetchActivatedTheme

	Fetch the activated theme.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFetchActivatedThemeRequest
	*/
	FetchActivatedTheme(ctx context.Context) ApiFetchActivatedThemeRequest

	// FetchActivatedThemeExecute executes the request
	//  @return Theme
	FetchActivatedThemeExecute(r ApiFetchActivatedThemeRequest) (*Theme, *http.Response, error)

	/*
	FetchThemeConfig Method for FetchThemeConfig

	Fetch configMap of theme by configured configMapName. It is deprecated.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiFetchThemeConfigRequest

	Deprecated
	*/
	FetchThemeConfig(ctx context.Context, name string) ApiFetchThemeConfigRequest

	// FetchThemeConfigExecute executes the request
	//  @return ConfigMap
	// Deprecated
	FetchThemeConfigExecute(r ApiFetchThemeConfigRequest) (*ConfigMap, *http.Response, error)

	/*
	FetchThemeJsonConfig Method for FetchThemeJsonConfig

	Fetch converted json config of theme by configured configMapName.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiFetchThemeJsonConfigRequest
	*/
	FetchThemeJsonConfig(ctx context.Context, name string) ApiFetchThemeJsonConfigRequest

	// FetchThemeJsonConfigExecute executes the request
	//  @return map[string]interface{}
	FetchThemeJsonConfigExecute(r ApiFetchThemeJsonConfigRequest) (map[string]interface{}, *http.Response, error)

	/*
	FetchThemeSetting Method for FetchThemeSetting

	Fetch setting of theme.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiFetchThemeSettingRequest
	*/
	FetchThemeSetting(ctx context.Context, name string) ApiFetchThemeSettingRequest

	// FetchThemeSettingExecute executes the request
	//  @return Setting
	FetchThemeSettingExecute(r ApiFetchThemeSettingRequest) (*Setting, *http.Response, error)

	/*
	InstallTheme Method for InstallTheme

	Install a theme by uploading a zip file.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInstallThemeRequest
	*/
	InstallTheme(ctx context.Context) ApiInstallThemeRequest

	// InstallThemeExecute executes the request
	//  @return Theme
	InstallThemeExecute(r ApiInstallThemeRequest) (*Theme, *http.Response, error)

	/*
	InstallThemeFromUri Method for InstallThemeFromUri

	Install a theme from uri.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInstallThemeFromUriRequest
	*/
	InstallThemeFromUri(ctx context.Context) ApiInstallThemeFromUriRequest

	// InstallThemeFromUriExecute executes the request
	//  @return Theme
	InstallThemeFromUriExecute(r ApiInstallThemeFromUriRequest) (*Theme, *http.Response, error)

	/*
	InvalidateCache Method for InvalidateCache

	Invalidate theme template cache.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiInvalidateCacheRequest
	*/
	InvalidateCache(ctx context.Context, name string) ApiInvalidateCacheRequest

	// InvalidateCacheExecute executes the request
	InvalidateCacheExecute(r ApiInvalidateCacheRequest) (*http.Response, error)

	/*
	ListThemes Method for ListThemes

	List themes.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListThemesRequest
	*/
	ListThemes(ctx context.Context) ApiListThemesRequest

	// ListThemesExecute executes the request
	//  @return ThemeList
	ListThemesExecute(r ApiListThemesRequest) (*ThemeList, *http.Response, error)

	/*
	Reload Method for Reload

	Reload theme setting.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiReloadRequest
	*/
	Reload(ctx context.Context, name string) ApiReloadRequest

	// ReloadExecute executes the request
	//  @return Theme
	ReloadExecute(r ApiReloadRequest) (*Theme, *http.Response, error)

	/*
	ResetThemeConfig Method for ResetThemeConfig

	Reset the configMap of theme setting.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiResetThemeConfigRequest
	*/
	ResetThemeConfig(ctx context.Context, name string) ApiResetThemeConfigRequest

	// ResetThemeConfigExecute executes the request
	//  @return ConfigMap
	ResetThemeConfigExecute(r ApiResetThemeConfigRequest) (*ConfigMap, *http.Response, error)

	/*
	UpdateThemeConfig Method for UpdateThemeConfig

	Update the configMap of theme setting. It is deprecated.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiUpdateThemeConfigRequest

	Deprecated
	*/
	UpdateThemeConfig(ctx context.Context, name string) ApiUpdateThemeConfigRequest

	// UpdateThemeConfigExecute executes the request
	//  @return ConfigMap
	// Deprecated
	UpdateThemeConfigExecute(r ApiUpdateThemeConfigRequest) (*ConfigMap, *http.Response, error)

	/*
	UpdateThemeJsonConfig Method for UpdateThemeJsonConfig

	Update the configMap of theme setting.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiUpdateThemeJsonConfigRequest
	*/
	UpdateThemeJsonConfig(ctx context.Context, name string) ApiUpdateThemeJsonConfigRequest

	// UpdateThemeJsonConfigExecute executes the request
	UpdateThemeJsonConfigExecute(r ApiUpdateThemeJsonConfigRequest) (*http.Response, error)

	/*
	UpgradeTheme Method for UpgradeTheme

	Upgrade theme

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiUpgradeThemeRequest
	*/
	UpgradeTheme(ctx context.Context, name string) ApiUpgradeThemeRequest

	// UpgradeThemeExecute executes the request
	UpgradeThemeExecute(r ApiUpgradeThemeRequest) (*http.Response, error)

	/*
	UpgradeThemeFromUri Method for UpgradeThemeFromUri

	Upgrade a theme from uri.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiUpgradeThemeFromUriRequest
	*/
	UpgradeThemeFromUri(ctx context.Context, name string) ApiUpgradeThemeFromUriRequest

	// UpgradeThemeFromUriExecute executes the request
	//  @return Theme
	UpgradeThemeFromUriExecute(r ApiUpgradeThemeFromUriRequest) (*Theme, *http.Response, error)
}

// ThemeV1alpha1ConsoleAPIService ThemeV1alpha1ConsoleAPI service
type ThemeV1alpha1ConsoleAPIService service

type ApiActivateThemeRequest struct {
	ctx context.Context
	ApiService ThemeV1alpha1ConsoleAPI
	name string
}

func (r ApiActivateThemeRequest) Execute() (*Theme, *http.Response, error) {
	return r.ApiService.ActivateThemeExecute(r)
}

/*
ActivateTheme Method for ActivateTheme

Activate a theme by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiActivateThemeRequest
*/
func (a *ThemeV1alpha1ConsoleAPIService) ActivateTheme(ctx context.Context, name string) ApiActivateThemeRequest {
	return ApiActivateThemeRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return Theme
func (a *ThemeV1alpha1ConsoleAPIService) ActivateThemeExecute(r ApiActivateThemeRequest) (*Theme, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Theme
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThemeV1alpha1ConsoleAPIService.ActivateTheme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/api.console.halo.run/v1alpha1/themes/{name}/activation"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Theme
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchActivatedThemeRequest struct {
	ctx context.Context
	ApiService ThemeV1alpha1ConsoleAPI
}

func (r ApiFetchActivatedThemeRequest) Execute() (*Theme, *http.Response, error) {
	return r.ApiService.FetchActivatedThemeExecute(r)
}

/*
FetchActivatedTheme Method for FetchActivatedTheme

Fetch the activated theme.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFetchActivatedThemeRequest
*/
func (a *ThemeV1alpha1ConsoleAPIService) FetchActivatedTheme(ctx context.Context) ApiFetchActivatedThemeRequest {
	return ApiFetchActivatedThemeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Theme
func (a *ThemeV1alpha1ConsoleAPIService) FetchActivatedThemeExecute(r ApiFetchActivatedThemeRequest) (*Theme, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Theme
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThemeV1alpha1ConsoleAPIService.FetchActivatedTheme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/api.console.halo.run/v1alpha1/themes/-/activation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Theme
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchThemeConfigRequest struct {
	ctx context.Context
	ApiService ThemeV1alpha1ConsoleAPI
	name string
}

func (r ApiFetchThemeConfigRequest) Execute() (*ConfigMap, *http.Response, error) {
	return r.ApiService.FetchThemeConfigExecute(r)
}

/*
FetchThemeConfig Method for FetchThemeConfig

Fetch configMap of theme by configured configMapName. It is deprecated.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiFetchThemeConfigRequest

Deprecated
*/
func (a *ThemeV1alpha1ConsoleAPIService) FetchThemeConfig(ctx context.Context, name string) ApiFetchThemeConfigRequest {
	return ApiFetchThemeConfigRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ConfigMap
// Deprecated
func (a *ThemeV1alpha1ConsoleAPIService) FetchThemeConfigExecute(r ApiFetchThemeConfigRequest) (*ConfigMap, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConfigMap
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThemeV1alpha1ConsoleAPIService.FetchThemeConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/api.console.halo.run/v1alpha1/themes/{name}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ConfigMap
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchThemeJsonConfigRequest struct {
	ctx context.Context
	ApiService ThemeV1alpha1ConsoleAPI
	name string
}

func (r ApiFetchThemeJsonConfigRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.FetchThemeJsonConfigExecute(r)
}

/*
FetchThemeJsonConfig Method for FetchThemeJsonConfig

Fetch converted json config of theme by configured configMapName.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiFetchThemeJsonConfigRequest
*/
func (a *ThemeV1alpha1ConsoleAPIService) FetchThemeJsonConfig(ctx context.Context, name string) ApiFetchThemeJsonConfigRequest {
	return ApiFetchThemeJsonConfigRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ThemeV1alpha1ConsoleAPIService) FetchThemeJsonConfigExecute(r ApiFetchThemeJsonConfigRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThemeV1alpha1ConsoleAPIService.FetchThemeJsonConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/api.console.halo.run/v1alpha1/themes/{name}/json-config"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchThemeSettingRequest struct {
	ctx context.Context
	ApiService ThemeV1alpha1ConsoleAPI
	name string
}

func (r ApiFetchThemeSettingRequest) Execute() (*Setting, *http.Response, error) {
	return r.ApiService.FetchThemeSettingExecute(r)
}

/*
FetchThemeSetting Method for FetchThemeSetting

Fetch setting of theme.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiFetchThemeSettingRequest
*/
func (a *ThemeV1alpha1ConsoleAPIService) FetchThemeSetting(ctx context.Context, name string) ApiFetchThemeSettingRequest {
	return ApiFetchThemeSettingRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return Setting
func (a *ThemeV1alpha1ConsoleAPIService) FetchThemeSettingExecute(r ApiFetchThemeSettingRequest) (*Setting, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Setting
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThemeV1alpha1ConsoleAPIService.FetchThemeSetting")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/api.console.halo.run/v1alpha1/themes/{name}/setting"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Setting
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInstallThemeRequest struct {
	ctx context.Context
	ApiService ThemeV1alpha1ConsoleAPI
}

func (r ApiInstallThemeRequest) Execute() (*Theme, *http.Response, error) {
	return r.ApiService.InstallThemeExecute(r)
}

/*
InstallTheme Method for InstallTheme

Install a theme by uploading a zip file.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiInstallThemeRequest
*/
func (a *ThemeV1alpha1ConsoleAPIService) InstallTheme(ctx context.Context) ApiInstallThemeRequest {
	return ApiInstallThemeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Theme
func (a *ThemeV1alpha1ConsoleAPIService) InstallThemeExecute(r ApiInstallThemeRequest) (*Theme, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Theme
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThemeV1alpha1ConsoleAPIService.InstallTheme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/api.console.halo.run/v1alpha1/themes/install"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Theme
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInstallThemeFromUriRequest struct {
	ctx context.Context
	ApiService ThemeV1alpha1ConsoleAPI
	installFromUriRequest *InstallFromUriRequest
}

func (r ApiInstallThemeFromUriRequest) InstallFromUriRequest(installFromUriRequest InstallFromUriRequest) ApiInstallThemeFromUriRequest {
	r.installFromUriRequest = &installFromUriRequest
	return r
}

func (r ApiInstallThemeFromUriRequest) Execute() (*Theme, *http.Response, error) {
	return r.ApiService.InstallThemeFromUriExecute(r)
}

/*
InstallThemeFromUri Method for InstallThemeFromUri

Install a theme from uri.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiInstallThemeFromUriRequest
*/
func (a *ThemeV1alpha1ConsoleAPIService) InstallThemeFromUri(ctx context.Context) ApiInstallThemeFromUriRequest {
	return ApiInstallThemeFromUriRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Theme
func (a *ThemeV1alpha1ConsoleAPIService) InstallThemeFromUriExecute(r ApiInstallThemeFromUriRequest) (*Theme, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Theme
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThemeV1alpha1ConsoleAPIService.InstallThemeFromUri")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/api.console.halo.run/v1alpha1/themes/-/install-from-uri"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.installFromUriRequest == nil {
		return localVarReturnValue, nil, reportError("installFromUriRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.installFromUriRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Theme
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInvalidateCacheRequest struct {
	ctx context.Context
	ApiService ThemeV1alpha1ConsoleAPI
	name string
}

func (r ApiInvalidateCacheRequest) Execute() (*http.Response, error) {
	return r.ApiService.InvalidateCacheExecute(r)
}

/*
InvalidateCache Method for InvalidateCache

Invalidate theme template cache.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiInvalidateCacheRequest
*/
func (a *ThemeV1alpha1ConsoleAPIService) InvalidateCache(ctx context.Context, name string) ApiInvalidateCacheRequest {
	return ApiInvalidateCacheRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *ThemeV1alpha1ConsoleAPIService) InvalidateCacheExecute(r ApiInvalidateCacheRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThemeV1alpha1ConsoleAPIService.InvalidateCache")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/api.console.halo.run/v1alpha1/themes/{name}/invalidate-cache"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListThemesRequest struct {
	ctx context.Context
	ApiService ThemeV1alpha1ConsoleAPI
	page *int32
	size *int32
	labelSelector *[]string
	fieldSelector *[]string
	uninstalled *bool
}

// Page number. Default is 0.
func (r ApiListThemesRequest) Page(page int32) ApiListThemesRequest {
	r.page = &page
	return r
}

// Size number. Default is 0.
func (r ApiListThemesRequest) Size(size int32) ApiListThemesRequest {
	r.size = &size
	return r
}

// Label selector. e.g.: hidden!&#x3D;true
func (r ApiListThemesRequest) LabelSelector(labelSelector []string) ApiListThemesRequest {
	r.labelSelector = &labelSelector
	return r
}

// Field selector. e.g.: metadata.name&#x3D;&#x3D;halo
func (r ApiListThemesRequest) FieldSelector(fieldSelector []string) ApiListThemesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// Whether to list uninstalled themes.
func (r ApiListThemesRequest) Uninstalled(uninstalled bool) ApiListThemesRequest {
	r.uninstalled = &uninstalled
	return r
}

func (r ApiListThemesRequest) Execute() (*ThemeList, *http.Response, error) {
	return r.ApiService.ListThemesExecute(r)
}

/*
ListThemes Method for ListThemes

List themes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListThemesRequest
*/
func (a *ThemeV1alpha1ConsoleAPIService) ListThemes(ctx context.Context) ApiListThemesRequest {
	return ApiListThemesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ThemeList
func (a *ThemeV1alpha1ConsoleAPIService) ListThemesExecute(r ApiListThemesRequest) (*ThemeList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ThemeList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThemeV1alpha1ConsoleAPIService.ListThemes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/api.console.halo.run/v1alpha1/themes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.labelSelector != nil {
		t := *r.labelSelector
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "labelSelector", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "labelSelector", t, "form", "multi")
		}
	}
	if r.fieldSelector != nil {
		t := *r.fieldSelector
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fieldSelector", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fieldSelector", t, "form", "multi")
		}
	}
	if r.uninstalled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uninstalled", r.uninstalled, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ThemeList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReloadRequest struct {
	ctx context.Context
	ApiService ThemeV1alpha1ConsoleAPI
	name string
}

func (r ApiReloadRequest) Execute() (*Theme, *http.Response, error) {
	return r.ApiService.ReloadExecute(r)
}

/*
Reload Method for Reload

Reload theme setting.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiReloadRequest
*/
func (a *ThemeV1alpha1ConsoleAPIService) Reload(ctx context.Context, name string) ApiReloadRequest {
	return ApiReloadRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return Theme
func (a *ThemeV1alpha1ConsoleAPIService) ReloadExecute(r ApiReloadRequest) (*Theme, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Theme
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThemeV1alpha1ConsoleAPIService.Reload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/api.console.halo.run/v1alpha1/themes/{name}/reload"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Theme
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResetThemeConfigRequest struct {
	ctx context.Context
	ApiService ThemeV1alpha1ConsoleAPI
	name string
}

func (r ApiResetThemeConfigRequest) Execute() (*ConfigMap, *http.Response, error) {
	return r.ApiService.ResetThemeConfigExecute(r)
}

/*
ResetThemeConfig Method for ResetThemeConfig

Reset the configMap of theme setting.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiResetThemeConfigRequest
*/
func (a *ThemeV1alpha1ConsoleAPIService) ResetThemeConfig(ctx context.Context, name string) ApiResetThemeConfigRequest {
	return ApiResetThemeConfigRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ConfigMap
func (a *ThemeV1alpha1ConsoleAPIService) ResetThemeConfigExecute(r ApiResetThemeConfigRequest) (*ConfigMap, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConfigMap
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThemeV1alpha1ConsoleAPIService.ResetThemeConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/api.console.halo.run/v1alpha1/themes/{name}/reset-config"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ConfigMap
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateThemeConfigRequest struct {
	ctx context.Context
	ApiService ThemeV1alpha1ConsoleAPI
	name string
	configMap *ConfigMap
}

func (r ApiUpdateThemeConfigRequest) ConfigMap(configMap ConfigMap) ApiUpdateThemeConfigRequest {
	r.configMap = &configMap
	return r
}

func (r ApiUpdateThemeConfigRequest) Execute() (*ConfigMap, *http.Response, error) {
	return r.ApiService.UpdateThemeConfigExecute(r)
}

/*
UpdateThemeConfig Method for UpdateThemeConfig

Update the configMap of theme setting. It is deprecated.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiUpdateThemeConfigRequest

Deprecated
*/
func (a *ThemeV1alpha1ConsoleAPIService) UpdateThemeConfig(ctx context.Context, name string) ApiUpdateThemeConfigRequest {
	return ApiUpdateThemeConfigRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ConfigMap
// Deprecated
func (a *ThemeV1alpha1ConsoleAPIService) UpdateThemeConfigExecute(r ApiUpdateThemeConfigRequest) (*ConfigMap, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConfigMap
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThemeV1alpha1ConsoleAPIService.UpdateThemeConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/api.console.halo.run/v1alpha1/themes/{name}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configMap == nil {
		return localVarReturnValue, nil, reportError("configMap is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configMap
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ConfigMap
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateThemeJsonConfigRequest struct {
	ctx context.Context
	ApiService ThemeV1alpha1ConsoleAPI
	name string
	body *map[string]interface{}
}

func (r ApiUpdateThemeJsonConfigRequest) Body(body map[string]interface{}) ApiUpdateThemeJsonConfigRequest {
	r.body = &body
	return r
}

func (r ApiUpdateThemeJsonConfigRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateThemeJsonConfigExecute(r)
}

/*
UpdateThemeJsonConfig Method for UpdateThemeJsonConfig

Update the configMap of theme setting.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiUpdateThemeJsonConfigRequest
*/
func (a *ThemeV1alpha1ConsoleAPIService) UpdateThemeJsonConfig(ctx context.Context, name string) ApiUpdateThemeJsonConfigRequest {
	return ApiUpdateThemeJsonConfigRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *ThemeV1alpha1ConsoleAPIService) UpdateThemeJsonConfigExecute(r ApiUpdateThemeJsonConfigRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThemeV1alpha1ConsoleAPIService.UpdateThemeJsonConfig")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/api.console.halo.run/v1alpha1/themes/{name}/json-config"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpgradeThemeRequest struct {
	ctx context.Context
	ApiService ThemeV1alpha1ConsoleAPI
	name string
	file *os.File
}

func (r ApiUpgradeThemeRequest) File(file *os.File) ApiUpgradeThemeRequest {
	r.file = file
	return r
}

func (r ApiUpgradeThemeRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpgradeThemeExecute(r)
}

/*
UpgradeTheme Method for UpgradeTheme

Upgrade theme

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiUpgradeThemeRequest
*/
func (a *ThemeV1alpha1ConsoleAPIService) UpgradeTheme(ctx context.Context, name string) ApiUpgradeThemeRequest {
	return ApiUpgradeThemeRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *ThemeV1alpha1ConsoleAPIService) UpgradeThemeExecute(r ApiUpgradeThemeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThemeV1alpha1ConsoleAPIService.UpgradeTheme")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/api.console.halo.run/v1alpha1/themes/{name}/upgrade"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.file == nil {
		return nil, reportError("file is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpgradeThemeFromUriRequest struct {
	ctx context.Context
	ApiService ThemeV1alpha1ConsoleAPI
	name string
	upgradeFromUriRequest *UpgradeFromUriRequest
}

func (r ApiUpgradeThemeFromUriRequest) UpgradeFromUriRequest(upgradeFromUriRequest UpgradeFromUriRequest) ApiUpgradeThemeFromUriRequest {
	r.upgradeFromUriRequest = &upgradeFromUriRequest
	return r
}

func (r ApiUpgradeThemeFromUriRequest) Execute() (*Theme, *http.Response, error) {
	return r.ApiService.UpgradeThemeFromUriExecute(r)
}

/*
UpgradeThemeFromUri Method for UpgradeThemeFromUri

Upgrade a theme from uri.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiUpgradeThemeFromUriRequest
*/
func (a *ThemeV1alpha1ConsoleAPIService) UpgradeThemeFromUri(ctx context.Context, name string) ApiUpgradeThemeFromUriRequest {
	return ApiUpgradeThemeFromUriRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return Theme
func (a *ThemeV1alpha1ConsoleAPIService) UpgradeThemeFromUriExecute(r ApiUpgradeThemeFromUriRequest) (*Theme, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Theme
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThemeV1alpha1ConsoleAPIService.UpgradeThemeFromUri")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/api.console.halo.run/v1alpha1/themes/{name}/upgrade-from-uri"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.upgradeFromUriRequest == nil {
		return localVarReturnValue, nil, reportError("upgradeFromUriRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.upgradeFromUriRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Theme
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
