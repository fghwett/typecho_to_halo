/*
Halo

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.20.18
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package console_sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


type PostV1alpha1ConsoleAPI interface {

	/*
	DeletePostContent Method for DeletePostContent

	Delete a content for post.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiDeletePostContentRequest
	*/
	DeletePostContent(ctx context.Context, name string) ApiDeletePostContentRequest

	// DeletePostContentExecute executes the request
	//  @return ContentWrapper
	DeletePostContentExecute(r ApiDeletePostContentRequest) (*ContentWrapper, *http.Response, error)

	/*
	DraftPost Method for DraftPost

	Draft a post.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDraftPostRequest
	*/
	DraftPost(ctx context.Context) ApiDraftPostRequest

	// DraftPostExecute executes the request
	//  @return Post
	DraftPostExecute(r ApiDraftPostRequest) (*Post, *http.Response, error)

	/*
	FetchPostContent Method for FetchPostContent

	Fetch content of post.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiFetchPostContentRequest
	*/
	FetchPostContent(ctx context.Context, name string) ApiFetchPostContentRequest

	// FetchPostContentExecute executes the request
	//  @return ContentWrapper
	FetchPostContentExecute(r ApiFetchPostContentRequest) (*ContentWrapper, *http.Response, error)

	/*
	FetchPostHeadContent Method for FetchPostHeadContent

	Fetch head content of post.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiFetchPostHeadContentRequest
	*/
	FetchPostHeadContent(ctx context.Context, name string) ApiFetchPostHeadContentRequest

	// FetchPostHeadContentExecute executes the request
	//  @return ContentWrapper
	FetchPostHeadContentExecute(r ApiFetchPostHeadContentRequest) (*ContentWrapper, *http.Response, error)

	/*
	FetchPostReleaseContent Method for FetchPostReleaseContent

	Fetch release content of post.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiFetchPostReleaseContentRequest
	*/
	FetchPostReleaseContent(ctx context.Context, name string) ApiFetchPostReleaseContentRequest

	// FetchPostReleaseContentExecute executes the request
	//  @return ContentWrapper
	FetchPostReleaseContentExecute(r ApiFetchPostReleaseContentRequest) (*ContentWrapper, *http.Response, error)

	/*
	ListPostSnapshots Method for ListPostSnapshots

	List all snapshots for post content.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiListPostSnapshotsRequest
	*/
	ListPostSnapshots(ctx context.Context, name string) ApiListPostSnapshotsRequest

	// ListPostSnapshotsExecute executes the request
	//  @return []ListedSnapshotDto
	ListPostSnapshotsExecute(r ApiListPostSnapshotsRequest) ([]ListedSnapshotDto, *http.Response, error)

	/*
	ListPosts Method for ListPosts

	List posts.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListPostsRequest
	*/
	ListPosts(ctx context.Context) ApiListPostsRequest

	// ListPostsExecute executes the request
	//  @return ListedPostList
	ListPostsExecute(r ApiListPostsRequest) (*ListedPostList, *http.Response, error)

	/*
	PublishPost Method for PublishPost

	Publish a post.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiPublishPostRequest
	*/
	PublishPost(ctx context.Context, name string) ApiPublishPostRequest

	// PublishPostExecute executes the request
	//  @return Post
	PublishPostExecute(r ApiPublishPostRequest) (*Post, *http.Response, error)

	/*
	RecyclePost Method for RecyclePost

	Recycle a post.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiRecyclePostRequest
	*/
	RecyclePost(ctx context.Context, name string) ApiRecyclePostRequest

	// RecyclePostExecute executes the request
	RecyclePostExecute(r ApiRecyclePostRequest) (*http.Response, error)

	/*
	RevertToSpecifiedSnapshotForPost Method for RevertToSpecifiedSnapshotForPost

	Revert to specified snapshot for post content.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiRevertToSpecifiedSnapshotForPostRequest
	*/
	RevertToSpecifiedSnapshotForPost(ctx context.Context, name string) ApiRevertToSpecifiedSnapshotForPostRequest

	// RevertToSpecifiedSnapshotForPostExecute executes the request
	//  @return Post
	RevertToSpecifiedSnapshotForPostExecute(r ApiRevertToSpecifiedSnapshotForPostRequest) (*Post, *http.Response, error)

	/*
	UnpublishPost Method for UnpublishPost

	Publish a post.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiUnpublishPostRequest
	*/
	UnpublishPost(ctx context.Context, name string) ApiUnpublishPostRequest

	// UnpublishPostExecute executes the request
	//  @return Post
	UnpublishPostExecute(r ApiUnpublishPostRequest) (*Post, *http.Response, error)

	/*
	UpdateDraftPost Method for UpdateDraftPost

	Update a post.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiUpdateDraftPostRequest
	*/
	UpdateDraftPost(ctx context.Context, name string) ApiUpdateDraftPostRequest

	// UpdateDraftPostExecute executes the request
	//  @return Post
	UpdateDraftPostExecute(r ApiUpdateDraftPostRequest) (*Post, *http.Response, error)

	/*
	UpdatePostContent Method for UpdatePostContent

	Update a post's content.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiUpdatePostContentRequest
	*/
	UpdatePostContent(ctx context.Context, name string) ApiUpdatePostContentRequest

	// UpdatePostContentExecute executes the request
	//  @return Post
	UpdatePostContentExecute(r ApiUpdatePostContentRequest) (*Post, *http.Response, error)
}

// PostV1alpha1ConsoleAPIService PostV1alpha1ConsoleAPI service
type PostV1alpha1ConsoleAPIService service

type ApiDeletePostContentRequest struct {
	ctx context.Context
	ApiService PostV1alpha1ConsoleAPI
	name string
	snapshotName *string
}

func (r ApiDeletePostContentRequest) SnapshotName(snapshotName string) ApiDeletePostContentRequest {
	r.snapshotName = &snapshotName
	return r
}

func (r ApiDeletePostContentRequest) Execute() (*ContentWrapper, *http.Response, error) {
	return r.ApiService.DeletePostContentExecute(r)
}

/*
DeletePostContent Method for DeletePostContent

Delete a content for post.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiDeletePostContentRequest
*/
func (a *PostV1alpha1ConsoleAPIService) DeletePostContent(ctx context.Context, name string) ApiDeletePostContentRequest {
	return ApiDeletePostContentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ContentWrapper
func (a *PostV1alpha1ConsoleAPIService) DeletePostContentExecute(r ApiDeletePostContentRequest) (*ContentWrapper, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentWrapper
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostV1alpha1ConsoleAPIService.DeletePostContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/api.console.halo.run/v1alpha1/posts/{name}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.snapshotName == nil {
		return localVarReturnValue, nil, reportError("snapshotName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "snapshotName", r.snapshotName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ContentWrapper
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDraftPostRequest struct {
	ctx context.Context
	ApiService PostV1alpha1ConsoleAPI
	postRequest *PostRequest
}

func (r ApiDraftPostRequest) PostRequest(postRequest PostRequest) ApiDraftPostRequest {
	r.postRequest = &postRequest
	return r
}

func (r ApiDraftPostRequest) Execute() (*Post, *http.Response, error) {
	return r.ApiService.DraftPostExecute(r)
}

/*
DraftPost Method for DraftPost

Draft a post.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDraftPostRequest
*/
func (a *PostV1alpha1ConsoleAPIService) DraftPost(ctx context.Context) ApiDraftPostRequest {
	return ApiDraftPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Post
func (a *PostV1alpha1ConsoleAPIService) DraftPostExecute(r ApiDraftPostRequest) (*Post, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Post
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostV1alpha1ConsoleAPIService.DraftPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/api.console.halo.run/v1alpha1/posts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postRequest == nil {
		return localVarReturnValue, nil, reportError("postRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Post
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchPostContentRequest struct {
	ctx context.Context
	ApiService PostV1alpha1ConsoleAPI
	name string
	snapshotName *string
}

func (r ApiFetchPostContentRequest) SnapshotName(snapshotName string) ApiFetchPostContentRequest {
	r.snapshotName = &snapshotName
	return r
}

func (r ApiFetchPostContentRequest) Execute() (*ContentWrapper, *http.Response, error) {
	return r.ApiService.FetchPostContentExecute(r)
}

/*
FetchPostContent Method for FetchPostContent

Fetch content of post.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiFetchPostContentRequest
*/
func (a *PostV1alpha1ConsoleAPIService) FetchPostContent(ctx context.Context, name string) ApiFetchPostContentRequest {
	return ApiFetchPostContentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ContentWrapper
func (a *PostV1alpha1ConsoleAPIService) FetchPostContentExecute(r ApiFetchPostContentRequest) (*ContentWrapper, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentWrapper
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostV1alpha1ConsoleAPIService.FetchPostContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/api.console.halo.run/v1alpha1/posts/{name}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.snapshotName == nil {
		return localVarReturnValue, nil, reportError("snapshotName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "snapshotName", r.snapshotName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ContentWrapper
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchPostHeadContentRequest struct {
	ctx context.Context
	ApiService PostV1alpha1ConsoleAPI
	name string
}

func (r ApiFetchPostHeadContentRequest) Execute() (*ContentWrapper, *http.Response, error) {
	return r.ApiService.FetchPostHeadContentExecute(r)
}

/*
FetchPostHeadContent Method for FetchPostHeadContent

Fetch head content of post.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiFetchPostHeadContentRequest
*/
func (a *PostV1alpha1ConsoleAPIService) FetchPostHeadContent(ctx context.Context, name string) ApiFetchPostHeadContentRequest {
	return ApiFetchPostHeadContentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ContentWrapper
func (a *PostV1alpha1ConsoleAPIService) FetchPostHeadContentExecute(r ApiFetchPostHeadContentRequest) (*ContentWrapper, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentWrapper
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostV1alpha1ConsoleAPIService.FetchPostHeadContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/api.console.halo.run/v1alpha1/posts/{name}/head-content"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ContentWrapper
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchPostReleaseContentRequest struct {
	ctx context.Context
	ApiService PostV1alpha1ConsoleAPI
	name string
}

func (r ApiFetchPostReleaseContentRequest) Execute() (*ContentWrapper, *http.Response, error) {
	return r.ApiService.FetchPostReleaseContentExecute(r)
}

/*
FetchPostReleaseContent Method for FetchPostReleaseContent

Fetch release content of post.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiFetchPostReleaseContentRequest
*/
func (a *PostV1alpha1ConsoleAPIService) FetchPostReleaseContent(ctx context.Context, name string) ApiFetchPostReleaseContentRequest {
	return ApiFetchPostReleaseContentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ContentWrapper
func (a *PostV1alpha1ConsoleAPIService) FetchPostReleaseContentExecute(r ApiFetchPostReleaseContentRequest) (*ContentWrapper, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentWrapper
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostV1alpha1ConsoleAPIService.FetchPostReleaseContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/api.console.halo.run/v1alpha1/posts/{name}/release-content"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ContentWrapper
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPostSnapshotsRequest struct {
	ctx context.Context
	ApiService PostV1alpha1ConsoleAPI
	name string
}

func (r ApiListPostSnapshotsRequest) Execute() ([]ListedSnapshotDto, *http.Response, error) {
	return r.ApiService.ListPostSnapshotsExecute(r)
}

/*
ListPostSnapshots Method for ListPostSnapshots

List all snapshots for post content.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiListPostSnapshotsRequest
*/
func (a *PostV1alpha1ConsoleAPIService) ListPostSnapshots(ctx context.Context, name string) ApiListPostSnapshotsRequest {
	return ApiListPostSnapshotsRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return []ListedSnapshotDto
func (a *PostV1alpha1ConsoleAPIService) ListPostSnapshotsExecute(r ApiListPostSnapshotsRequest) ([]ListedSnapshotDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ListedSnapshotDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostV1alpha1ConsoleAPIService.ListPostSnapshots")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/api.console.halo.run/v1alpha1/posts/{name}/snapshot"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v []ListedSnapshotDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPostsRequest struct {
	ctx context.Context
	ApiService PostV1alpha1ConsoleAPI
	page *int32
	size *int32
	labelSelector *[]string
	fieldSelector *[]string
	sort *[]string
	publishPhase *string
	keyword *string
	categoryWithChildren *string
}

// Page number. Default is 0.
func (r ApiListPostsRequest) Page(page int32) ApiListPostsRequest {
	r.page = &page
	return r
}

// Size number. Default is 0.
func (r ApiListPostsRequest) Size(size int32) ApiListPostsRequest {
	r.size = &size
	return r
}

// Label selector. e.g.: hidden!&#x3D;true
func (r ApiListPostsRequest) LabelSelector(labelSelector []string) ApiListPostsRequest {
	r.labelSelector = &labelSelector
	return r
}

// Field selector. e.g.: metadata.name&#x3D;&#x3D;halo
func (r ApiListPostsRequest) FieldSelector(fieldSelector []string) ApiListPostsRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiListPostsRequest) Sort(sort []string) ApiListPostsRequest {
	r.sort = &sort
	return r
}

// Posts filtered by publish phase.
func (r ApiListPostsRequest) PublishPhase(publishPhase string) ApiListPostsRequest {
	r.publishPhase = &publishPhase
	return r
}

// Posts filtered by keyword.
func (r ApiListPostsRequest) Keyword(keyword string) ApiListPostsRequest {
	r.keyword = &keyword
	return r
}

// Posts filtered by category including sub-categories.
func (r ApiListPostsRequest) CategoryWithChildren(categoryWithChildren string) ApiListPostsRequest {
	r.categoryWithChildren = &categoryWithChildren
	return r
}

func (r ApiListPostsRequest) Execute() (*ListedPostList, *http.Response, error) {
	return r.ApiService.ListPostsExecute(r)
}

/*
ListPosts Method for ListPosts

List posts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListPostsRequest
*/
func (a *PostV1alpha1ConsoleAPIService) ListPosts(ctx context.Context) ApiListPostsRequest {
	return ApiListPostsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListedPostList
func (a *PostV1alpha1ConsoleAPIService) ListPostsExecute(r ApiListPostsRequest) (*ListedPostList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListedPostList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostV1alpha1ConsoleAPIService.ListPosts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/api.console.halo.run/v1alpha1/posts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.labelSelector != nil {
		t := *r.labelSelector
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "labelSelector", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "labelSelector", t, "form", "multi")
		}
	}
	if r.fieldSelector != nil {
		t := *r.fieldSelector
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fieldSelector", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fieldSelector", t, "form", "multi")
		}
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "form", "multi")
		}
	}
	if r.publishPhase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "publishPhase", r.publishPhase, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.categoryWithChildren != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryWithChildren", r.categoryWithChildren, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ListedPostList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublishPostRequest struct {
	ctx context.Context
	ApiService PostV1alpha1ConsoleAPI
	name string
	headSnapshot *string
	async *bool
}

// Head snapshot name of content.
func (r ApiPublishPostRequest) HeadSnapshot(headSnapshot string) ApiPublishPostRequest {
	r.headSnapshot = &headSnapshot
	return r
}

func (r ApiPublishPostRequest) Async(async bool) ApiPublishPostRequest {
	r.async = &async
	return r
}

func (r ApiPublishPostRequest) Execute() (*Post, *http.Response, error) {
	return r.ApiService.PublishPostExecute(r)
}

/*
PublishPost Method for PublishPost

Publish a post.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiPublishPostRequest
*/
func (a *PostV1alpha1ConsoleAPIService) PublishPost(ctx context.Context, name string) ApiPublishPostRequest {
	return ApiPublishPostRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return Post
func (a *PostV1alpha1ConsoleAPIService) PublishPostExecute(r ApiPublishPostRequest) (*Post, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Post
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostV1alpha1ConsoleAPIService.PublishPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/api.console.halo.run/v1alpha1/posts/{name}/publish"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.headSnapshot != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headSnapshot", r.headSnapshot, "form", "")
	}
	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Post
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRecyclePostRequest struct {
	ctx context.Context
	ApiService PostV1alpha1ConsoleAPI
	name string
}

func (r ApiRecyclePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.RecyclePostExecute(r)
}

/*
RecyclePost Method for RecyclePost

Recycle a post.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiRecyclePostRequest
*/
func (a *PostV1alpha1ConsoleAPIService) RecyclePost(ctx context.Context, name string) ApiRecyclePostRequest {
	return ApiRecyclePostRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *PostV1alpha1ConsoleAPIService) RecyclePostExecute(r ApiRecyclePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostV1alpha1ConsoleAPIService.RecyclePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/api.console.halo.run/v1alpha1/posts/{name}/recycle"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRevertToSpecifiedSnapshotForPostRequest struct {
	ctx context.Context
	ApiService PostV1alpha1ConsoleAPI
	name string
	revertSnapshotForPostParam *RevertSnapshotForPostParam
}

func (r ApiRevertToSpecifiedSnapshotForPostRequest) RevertSnapshotForPostParam(revertSnapshotForPostParam RevertSnapshotForPostParam) ApiRevertToSpecifiedSnapshotForPostRequest {
	r.revertSnapshotForPostParam = &revertSnapshotForPostParam
	return r
}

func (r ApiRevertToSpecifiedSnapshotForPostRequest) Execute() (*Post, *http.Response, error) {
	return r.ApiService.RevertToSpecifiedSnapshotForPostExecute(r)
}

/*
RevertToSpecifiedSnapshotForPost Method for RevertToSpecifiedSnapshotForPost

Revert to specified snapshot for post content.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiRevertToSpecifiedSnapshotForPostRequest
*/
func (a *PostV1alpha1ConsoleAPIService) RevertToSpecifiedSnapshotForPost(ctx context.Context, name string) ApiRevertToSpecifiedSnapshotForPostRequest {
	return ApiRevertToSpecifiedSnapshotForPostRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return Post
func (a *PostV1alpha1ConsoleAPIService) RevertToSpecifiedSnapshotForPostExecute(r ApiRevertToSpecifiedSnapshotForPostRequest) (*Post, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Post
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostV1alpha1ConsoleAPIService.RevertToSpecifiedSnapshotForPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/api.console.halo.run/v1alpha1/posts/{name}/revert-content"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revertSnapshotForPostParam == nil {
		return localVarReturnValue, nil, reportError("revertSnapshotForPostParam is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.revertSnapshotForPostParam
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Post
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnpublishPostRequest struct {
	ctx context.Context
	ApiService PostV1alpha1ConsoleAPI
	name string
}

func (r ApiUnpublishPostRequest) Execute() (*Post, *http.Response, error) {
	return r.ApiService.UnpublishPostExecute(r)
}

/*
UnpublishPost Method for UnpublishPost

Publish a post.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiUnpublishPostRequest
*/
func (a *PostV1alpha1ConsoleAPIService) UnpublishPost(ctx context.Context, name string) ApiUnpublishPostRequest {
	return ApiUnpublishPostRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return Post
func (a *PostV1alpha1ConsoleAPIService) UnpublishPostExecute(r ApiUnpublishPostRequest) (*Post, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Post
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostV1alpha1ConsoleAPIService.UnpublishPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/api.console.halo.run/v1alpha1/posts/{name}/unpublish"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Post
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDraftPostRequest struct {
	ctx context.Context
	ApiService PostV1alpha1ConsoleAPI
	name string
	postRequest *PostRequest
}

func (r ApiUpdateDraftPostRequest) PostRequest(postRequest PostRequest) ApiUpdateDraftPostRequest {
	r.postRequest = &postRequest
	return r
}

func (r ApiUpdateDraftPostRequest) Execute() (*Post, *http.Response, error) {
	return r.ApiService.UpdateDraftPostExecute(r)
}

/*
UpdateDraftPost Method for UpdateDraftPost

Update a post.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiUpdateDraftPostRequest
*/
func (a *PostV1alpha1ConsoleAPIService) UpdateDraftPost(ctx context.Context, name string) ApiUpdateDraftPostRequest {
	return ApiUpdateDraftPostRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return Post
func (a *PostV1alpha1ConsoleAPIService) UpdateDraftPostExecute(r ApiUpdateDraftPostRequest) (*Post, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Post
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostV1alpha1ConsoleAPIService.UpdateDraftPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/api.console.halo.run/v1alpha1/posts/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postRequest == nil {
		return localVarReturnValue, nil, reportError("postRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Post
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePostContentRequest struct {
	ctx context.Context
	ApiService PostV1alpha1ConsoleAPI
	name string
	content *Content
}

func (r ApiUpdatePostContentRequest) Content(content Content) ApiUpdatePostContentRequest {
	r.content = &content
	return r
}

func (r ApiUpdatePostContentRequest) Execute() (*Post, *http.Response, error) {
	return r.ApiService.UpdatePostContentExecute(r)
}

/*
UpdatePostContent Method for UpdatePostContent

Update a post's content.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiUpdatePostContentRequest
*/
func (a *PostV1alpha1ConsoleAPIService) UpdatePostContent(ctx context.Context, name string) ApiUpdatePostContentRequest {
	return ApiUpdatePostContentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return Post
func (a *PostV1alpha1ConsoleAPIService) UpdatePostContentExecute(r ApiUpdatePostContentRequest) (*Post, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Post
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostV1alpha1ConsoleAPIService.UpdatePostContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/api.console.halo.run/v1alpha1/posts/{name}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.content == nil {
		return localVarReturnValue, nil, reportError("content is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.content
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Post
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
